import { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import * as z from 'zod';

export declare class Agent {
    static name: string;
    static description: string;
    protected options: AgentOptions;
    protected logger: RunnerLogger;
    protected workingDir: string;
    protected session: Session;
    constructor(options: AgentOptions);
    /**
     * Execute the agent with the given prompt.
     * This method runs the full agentic loop with the execution engine.
     *
     * @param prompt - The user's prompt/instruction
     * @returns AsyncGenerator of SDKEvent objects
     */
    query(prompt: string): AsyncGenerator<SDKEvent>;
    /**
     * Build agent model string from provider config
     */
    private buildAgentModelString;
    /**
     * Apply tool filtering based on allowedTools/disabledTools
     */
    private applyToolFiltering;
    /**
     * Translate internal Event objects to SDK events
     */
    private translateEvent;
}

export declare interface AgentOptions {
    modelProvider: ModelProvider;
    session?: Session;
    abortController?: AbortController;
    allowedTools?: string[];
    disabledTools?: string[];
    requestPermission?: (permissionRequest: PermissionRequest) => Promise<PermissionRequestResult>;
    mcpServers?: Record<string, MCPServerConfig>;
    hooks?: QueryHooks;
    logger?: RunnerLogger;
    workingDirectory?: string;
    env?: Record<string, string>;
    additionalDirectories?: string[];
    integrationId?: string;
    hmacKey?: string;
    copilotToken?: string;
}

/**
 * Base interface for all hook inputs
 */
export declare interface BaseHookInput {
    timestamp: number;
    cwd: string;
}

export declare abstract class BaseLogger implements RunnerLogger {
    protected logLevel?: LogLevel;
    protected debugEnvironmentVariables?: string[];
    private secretFilter;
    constructor(logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    filterSecrets(messageOrError: string | Error): string | Error;
    /**
     * Returns true if the log level is not set, or the log level is set and the level is enabled.
     */
    shouldLog(level: LogLevel): boolean;
    isDebug(): boolean;
    abstract log(message: string): void;
    abstract info(message: string): void;
    abstract debug(message: string): void;
    abstract notice(message: string | Error): void;
    abstract warning(message: string | Error): void;
    abstract error(message: string | Error): void;
    abstract startGroup(name: string, level?: LogLevel): void;
    abstract endGroup(level?: LogLevel): void;
}

export declare abstract class BaseSession implements Session {
    readonly id: string;
    readonly startTime: Date;
    readonly selectedModel?: string;
    protected logger: RunnerLogger;
    constructor({ id, startTime, selectedModel }?: Partial<SessionMetadata>, logger?: RunnerLogger);
    abstract getChatMessages(): Promise<ChatCompletionMessageParam[]>;
    abstract addChatMessage(message: ChatCompletionMessageParam): Promise<void>;
    abstract onAbort(): Promise<void>;
}

declare type BinaryResult = {
    data: string;
    mimeType: string;
    type: string;
};

declare interface CodeChangeMetrics {
    linesAdded: number;
    linesRemoved: number;
    filesModified: Set<string>;
}

declare type Command = {
    readonly identifier: string;
    readonly readOnly: boolean;
};

export declare class CompoundLogger implements RunnerLogger {
    readonly loggers: RunnerLogger[];
    constructor(loggers: RunnerLogger[]);
    isDebug(): boolean;
    debug(message: string): void;
    log(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
}

export declare class ConsoleLogger extends BaseLogger implements RunnerLogger {
    constructor(logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    log(message: string): void;
    debug(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
}

declare enum ContentFilterMode {
    None = "none",
    Markdown = "markdown",
    HiddenCharacters = "hidden_characters"
}

/**
 * Adapter that wraps the CLI SessionManager to implement the SDK Session interface
 */
export declare class CopilotCLISession extends BaseSession {
    private cliSessionManager;
    constructor(cliSessionManager: SessionManager_2, logger?: RunnerLogger);
    getChatMessages(): Promise<ChatCompletionMessageParam[]>;
    addChatMessage(message: ChatCompletionMessageParam): Promise<void>;
    onAbort(): Promise<void>;
    /**
     * Save this session immediately
     */
    save(): Promise<void>;
}

/**
 * Adapter that wraps the CLI SessionManager to implement the SDK SessionManager interface
 */
export declare class CopilotCLISessionManager implements SessionManager {
    private logger;
    constructor(options?: SessionManagerOptions);
    createSession(): Promise<CopilotCLISession>;
    getLastSession(): Promise<CopilotCLISession>;
    getSession(id: string): Promise<CopilotCLISession>;
    listSessions(): Promise<SessionMetadata[]>;
    saveSession(session: CopilotCLISession): Promise<void>;
    deleteSession(_session: CopilotCLISession): Promise<void>;
}

export declare type ErrorOccurredHook = (input: ErrorOccurredHookInput) => Promise<ErrorOccurredHookOutput | void>;

/**
 * Error occurred hook types
 */
export declare interface ErrorOccurredHookInput extends BaseHookInput {
    error: Error;
    errorContext: "model_call" | "tool_execution" | "system" | "user_input";
    recoverable: boolean;
}

export declare interface ErrorOccurredHookOutput {
    suppressOutput?: boolean;
    errorHandling?: "retry" | "skip" | "abort";
    retryCount?: number;
    userNotification?: string;
}

export declare function executeHooks<TInput extends BaseHookInput, TOutput>(hooks: ((input: TInput) => Promise<TOutput | void>)[] | undefined, input: TInput, logger: RunnerLogger): Promise<void | TOutput>;

export declare class FileLogger extends BaseLogger implements RunnerLogger {
    private readonly filePath;
    /** Promise that resolves when pending writes are complete. Used to serialize
     * writes and for testing. */
    writeQueue: Promise<void>;
    constructor(filePath: string, logLevel?: LogLevel, debugEnvironmentVariables?: string[]);
    log(message: string): void;
    debug(message: string): void;
    info(message: string): void;
    notice(message: string | Error): void;
    warning(message: string | Error): void;
    error(message: string | Error): void;
    startGroup(name: string, level?: LogLevel): void;
    endGroup(level?: LogLevel): void;
    write(category: string, message: string): void;
    private performWrite;
}

/**
 * Simple in-memory session implementation
 */
export declare class InMemorySession extends BaseSession {
    private messages;
    constructor({ chatMessages, ...baseProps }?: Partial<Exclude<Session, "messageCount">> & {
        chatMessages?: ChatCompletionMessageParam[];
    }, logger?: RunnerLogger);
    getChatMessages(): Promise<ChatCompletionMessageParam[]>;
    addChatMessage(message: ChatCompletionMessageParam): Promise<void>;
    onAbort(): Promise<void>;
}

export declare class InMemorySessionManager implements SessionManager<InMemorySession> {
    private sessions;
    private logger;
    constructor(options?: {
        logger?: RunnerLogger;
    });
    createSession(): Promise<InMemorySession>;
    getLastSession(): Promise<InMemorySession>;
    getSession(id: string): Promise<InMemorySession>;
    listSessions(): Promise<{
        id: string;
        startTime: Date;
        selectedModel?: string;
    }[]>;
    saveSession(session: InMemorySession): Promise<void>;
    enableAutoSave(): void;
    deleteSession(session: InMemorySession): Promise<void>;
}

/**
 * Returns true if the DEBUG or COPILOT_AGENT_DEBUG environment variable is set to 1 or true (case-insensitive).
 * If additionalVariables are provided, they are also checked.
 * @param additionalVariables Additional environment variables to check for debug logging.
 */
export declare function isDebugEnvironment(...additionalVariables: string[]): boolean;

export declare enum LogLevel {
    None = 0,
    Error = 1,// 1
    Warning = 2,// 2
    Info = 4,// 4
    Debug = 8,// 8
    All = 15,
    Default = 7
}

declare interface MCPInMemoryServerConfig extends MCPServerConfigBase {
    type: "memory";
    serverInstance: McpServer;
}

declare interface MCPLocalServerConfig extends MCPServerConfigBase {
    type?: "local" | "stdio";
    command: string;
    args: string[];
    /**
     * An object of the environment variables to pass to the server. Key is whats sent to the MCP Server. Value is whats read from the actions environment. Empty means no env vars passed.
     */
    env?: Record<string, string>;
}

/**
 * A permission request for invoking an MCP tool.
 */
declare type MCPPermissionRequest = {
    readonly kind: "mcp";
    /** The name of the MCP Server being targeted e.g. "github-mcp-server" */
    readonly serverName: string;
    /** The name of the tool being targeted e.g. "list_issues" */
    readonly toolName: string;
    /** The title of the tool being targeted e.g. "List Issues" */
    readonly toolTitle: string;
    /**
     * The _hopefully_ JSON arguments that will be passed to the MCP tool.
     *
     * This should be an object, but it's not parsed before this point so we can't guarantee that.
     * */
    readonly args: unknown;
    /**
     * Whether the tool is read-only (e.g. a `view` operation) or not (e.g. an `edit` operation).
     */
    readonly readOnly: boolean;
};

declare interface MCPRemoteServerConfig extends MCPServerConfigBase {
    type: "http" | "sse";
    /**
     * URL of the remote server
     * NOTE: this has to be converted to a URL object before giving to transport.
     * TransportFactory will handle this conversion.
     */
    url: string;
    /**
     * Optional. HTTP headers to include in requests to the remote server.
     * This can be used for authentication or other purposes.
     * For example, you might include an Authorization header.
     */
    headers?: Record<string, string>;
}

declare type MCPServerConfig = MCPLocalServerConfig | MCPRemoteServerConfig | MCPInMemoryServerConfig;

declare interface MCPServerConfigBase {
    /**
     * List of tools to include from this server. [] means none. "*" means all.
     */
    tools: string[];
    /**
     * Indicates "remote" or "local" server type.
     * If not specified, defaults to "local".
     */
    type?: string;
    /**
     * Optional. Denotes if this is a MCP server we have defined to be used when
     * the user has not provided their own MCP server config.
     *
     * Marked optional as configs coming from users will/should not have this set. Defaults to `false`.
     */
    isDefaultServer?: boolean;
    /**
     * Optional. Either a content filter mode for all tools from this server, or a map of tool name to content filter mode for the tool with that name.
     * If not specified, defaults to "hidden_characters"
     */
    filterMapping?: Record<string, ContentFilterMode> | ContentFilterMode;
}

declare interface ModelMetrics {
    requests: {
        count: number;
        cost: number;
    };
    usage: {
        inputTokens: number;
        outputTokens: number;
        cacheReadTokens: number;
        cacheWriteTokens: number;
    };
}

export declare interface ModelProvider {
    type: "openai" | "anthropic" | "copilot";
    model: string;
}

export declare class NoopLogger extends BaseLogger implements RunnerLogger {
    constructor();
    debug(_message: string): void;
    log(_message: string): void;
    info(_message: string): void;
    notice(_message: string | Error): void;
    warning(_message: string | Error): void;
    error(_message: string | Error): void;
    startGroup(_name: string, _level?: LogLevel): void;
    endGroup(_level?: LogLevel): void;
}

declare type OnTimelineEntriesChange = (entries: TimelineEntry[]) => void;

/**
 * A permission request which will be used to check tool or path usage against config and/or request user approval.
 */
declare type PermissionRequest = ShellPermissionRequest | WritePermissionRequest | MCPPermissionRequest;

/**
 * The result of requesting permissions.
 */
declare type PermissionRequestResult = {
    readonly kind: "approved";
} | {
    readonly kind: "denied-by-rules";
    rules: ReadonlyArray<Rule>;
} | {
    readonly kind: "denied-no-approval-rule-and-could-not-request-from-user";
} | {
    readonly kind: "denied-interactively-by-user";
};

/**
 * This is just a type to warn that there's a good chance it's not a real path, because
 * it was _very_ heuristically parsed out of a command.
 */
declare type PossiblePath = string;

export declare type PostToolUseHook = (input: PostToolUseHookInput) => Promise<PostToolUseHookOutput | void>;

/**
 * Post-tool use hook types
 */
export declare interface PostToolUseHookInput extends BaseHookInput {
    toolName: string;
    toolArgs: unknown;
    toolResult: ToolResultExpanded;
}

export declare interface PostToolUseHookOutput {
    modifiedResult?: ToolResultExpanded;
    additionalContext?: string;
    suppressOutput?: boolean;
}

export declare type PreToolUseHook = (input: PreToolUseHookInput) => Promise<PreToolUseHookOutput | void>;

/**
 * Pre-tool use hook types
 */
export declare interface PreToolUseHookInput extends BaseHookInput {
    toolName: string;
    toolArgs: unknown;
}

export declare interface PreToolUseHookOutput {
    permissionDecision?: "allow" | "deny" | "ask";
    permissionDecisionReason?: string;
    modifiedArgs?: unknown;
    additionalContext?: string;
    suppressOutput?: boolean;
}

/**
 * Functional query API that provides a Claude Code-inspired interface.
 * This is a thin wrapper around the Agent class for simple use cases.
 *
 * @param options - Query configuration options
 * @returns AsyncGenerator of SDKEvent objects
 */
export declare function query(options: QueryOptions): AsyncIterable<SDKEvent>;

/**
 * Hook system with arrays of specific hook callbacks
 */
export declare interface QueryHooks {
    preToolUse?: PreToolUseHook[];
    postToolUse?: PostToolUseHook[];
    userPromptSubmitted?: UserPromptSubmittedHook[];
    sessionStart?: SessionStartHook[];
    sessionEnd?: SessionEndHook[];
    errorOccurred?: ErrorOccurredHook[];
}

export declare type QueryOptions = AgentOptions & {
    prompt: string;
};

/**
 * A Rule defines a pattern for matching permission requests.
 *
 * It is unfortunately generically named because it is intended to match across
 * different types of tool uses, e.g. `Shell(touch)` or `GitHubMCP(list_issues)`,
 * `view(.env-secrets)`
 */
declare type Rule = {
    /**
     * The kind of rule that should be matched e.g. `Shell` or `GitHubMCP`.
     */
    readonly kind: string;
    /**
     * If null, matches all arguments to the kind.
     */
    readonly argument: string | null;
};

export declare interface RunnerLogger {
    /**
     * Log a message ignoring the configured log level.
     * This is useful for logging messages that should always be logged, regardless of the log level.
     * @param message The message to log.
     */
    log(message: string): void;
    /**
     * Returns true if the environment is set to debug.
     * Note: This is not the same as the log level being set to debug.
     */
    isDebug(): boolean;
    /**
     * Log a debug message. This is only logged if the log level is set to debug.
     * @param message The message to log.
     */
    debug(message: string): void;
    /**
     * Log an info message. This is only logged if the log level is set to info or debug.
     * @param message The message to log.
     */
    info(message: string): void;
    /**
     * Log a notice message. This is only logged if the log level is set to warning, info, or debug,
     * but logs using the logger's info method.
     * This is useful for logging messages that are not errors, but are important enough to log on
     * less verbose log levels.
     * @param message The message to log.
     */
    notice(message: string | Error): void;
    /**
     * Log a warning message. This is only logged if the log level is set to warning, info, or debug
     * @param message The message to log.
     */
    warning(message: string | Error): void;
    /**
     * Log an error message. This is only logged if the log level is set to error, warning, info, or debug
     * @param message The message to log.
     */
    error(message: string | Error): void;
    /**
     * Log a message that starts a new group.
     * @param name The name of the group.
     * @param level The log level of the group. Defaults to info.
     */
    startGroup(name: string, level?: LogLevel): void;
    /**
     * Log a message that ends the current group.
     * @param level The log level of the group. Defaults to info.
     */
    endGroup(level?: LogLevel): void;
}

export declare type SDKCompleteEvent = {
    type: "complete";
    finalMessage?: string;
};

export declare type SDKErrorEvent = {
    type: "error";
    error: Error;
};

export declare type SDKEvent = SDKThinkingEvent | SDKMessageEvent | SDKToolUseEvent | SDKToolResultEvent | SDKErrorEvent | SDKCompleteEvent;

export declare type SDKMessageEvent = {
    type: "message";
    content: string;
    role: "assistant" | "user";
};

/**
 * SDK Event types that agents emit
 */
export declare type SDKThinkingEvent = {
    type: "thinking";
    content: string;
};

export declare type SDKToolResultEvent = {
    type: "tool_result";
    toolName: string;
    result: ToolResultExpanded;
    toolCallId?: string;
};

export declare type SDKToolUseEvent = {
    type: "tool_use";
    toolName: string;
    args: unknown;
    toolCallId?: string;
};

/**
 * Session interface for managing conversation state
 */
export declare interface Session extends SessionMetadata {
    /**
     * Get all chat messages in the session (for model context)
     */
    getChatMessages(): Promise<ChatCompletionMessageParam[]>;
    /**
     * Add a chat message to the session
     */
    addChatMessage(message: ChatCompletionMessageParam): Promise<void>;
    /**
     * Handle abortion/interruption of operations (e.g., complete orphaned tool calls)
     */
    onAbort(): Promise<void>;
}

export declare type SessionEndHook = (input: SessionEndHookInput) => Promise<SessionEndHookOutput | void>;

/**
 * Session end hook types
 */
export declare interface SessionEndHookInput extends BaseHookInput {
    reason: "complete" | "error" | "abort" | "timeout" | "user_exit";
    finalMessage?: string;
    error?: Error;
}

export declare interface SessionEndHookOutput {
    suppressOutput?: boolean;
    cleanupActions?: string[];
    sessionSummary?: string;
}

declare type SessionInitMode = {
    kind: "new";
} | {
    kind: "resume-last";
} | {
    kind: "resume";
    sessionId: string;
} | {
    kind: "resume-with-picker";
};

/**
 * SessionManager interface for managing multiple sessions
 */
export declare interface SessionManager<TSession extends Session = Session> {
    /**
     * Create a new session
     */
    createSession(): Promise<TSession>;
    /**
     * Get the last (most recent) session
     */
    getLastSession(): Promise<TSession>;
    /**
     * Get a specific session by ID
     */
    getSession(id: string): Promise<TSession>;
    /**
     * List all available sessions
     */
    listSessions(): Promise<SessionMetadata[]>;
    /**
     * Save session state immediately
     */
    saveSession(session: TSession): Promise<void>;
    /**
     * Delete a session
     * @param options Options including session to delete
     */
    deleteSession(session: TSession): Promise<void>;
}

declare class SessionManager_2 {
    private currentSession;
    private onTimelineEntriesChangeCallback;
    private debounceSave;
    private logger;
    private needsSessionPicker;
    private autoSaveEnabled;
    private usageMetrics;
    static create(initMode: SessionInitMode): Promise<SessionManager_2>;
    /**
     * Check if there are multiple sessions available for resuming.
     * @returns true if there are multiple sessions, false otherwise
     */
    static hasMultipleSessions(): Promise<boolean>;
    constructor();
    /**
     * Set the logger for the session manager.
     * @param logger The logger to use for logging.
     */
    setLogger(logger: RunnerLogger): void;
    /**
     * Get the current logger for the session manager.
     * @returns The current logger.
     */
    getLogger(): RunnerLogger;
    /**
     * Check if the session manager is waiting for session picker.
     * @returns true if session picker is needed
     */
    isWaitingForSessionPicker(): boolean;
    /**
     * Clear the session picker flag and load a specific session.
     * @param sessionId The session ID to load
     */
    selectSession(sessionId: string): Promise<void>;
    /**
     * Set a callback to be notified when the timeline entries change
     * @param callback The callback to be called with the new timeline entries
     */
    setOnTimelineEntriesChangeCallback(callback: OnTimelineEntriesChange | null): void;
    /**
     * Notify listeners of changes to the timeline entries. It passes a copy
     * of the timeline entries array.
     */
    private notifyTimelineEntriesChange;
    /**
     * Enable auto-saving of the session after a new timeline entry or chat
     * message is added to it.
     */
    enableAutoSave(): void;
    /**
     * Force save the current session immediately, bypassing any debouncing or auto-save logic.
     */
    forceSave(): Promise<void>;
    /** Schedule a save of the current session. Debounced. */
    private scheduleSave;
    /**
     * Get the timeline entries for the current session
     * @returns An array of timeline entries
     */
    getTimelineEntries(): (({
        type: "copilot";
        text: string;
    } | {
        type: "error";
        text: string;
    } | {
        type: "info";
        text: string;
    } | {
        type: "user";
        text: string;
        expandedText?: string | undefined;
        mentions?: {
            type: "file" | "directory" | "image" | "unresolved";
            displayText: string;
            fullPath: string;
            startIndex: number;
        }[] | undefined;
        imageAttachments?: {
            type: "image_url";
            image_url: {
                url: string;
            };
        }[] | undefined;
    } | {
        name: string;
        type: "tool_call_requested";
        callId: string;
        intentionSummary: string | null;
        toolTitle?: string | undefined;
        arguments?: unknown;
        partialOutput?: string | undefined;
        isHidden?: boolean | undefined;
        isAlwaysExpanded?: boolean | undefined;
        showNoContent?: boolean | undefined;
    } | {
        result: {
            log: string;
            type: "success";
            markdown?: boolean | undefined;
        } | {
            log: string;
            type: "failure";
            markdown?: boolean | undefined;
        } | {
            type: "rejected";
            markdown?: boolean | undefined;
        } | {
            log: string;
            type: "denied";
            markdown?: boolean | undefined;
        };
        name: string;
        type: "tool_call_completed";
        callId: string;
        intentionSummary: string | null;
        toolTitle?: string | undefined;
        arguments?: unknown;
        isHidden?: boolean | undefined;
        isAlwaysExpanded?: boolean | undefined;
        showNoContent?: boolean | undefined;
    }) & {
        id: string;
        timestamp: Date;
    })[];
    /**
     * Load a history session from disk.
     * @param filename The name of the file to load
     */
    private loadHistorySession;
    /**
     * Save the current session to disk
     * @param session The session to save
     */
    private saveHistorySession;
    /**
     * Get the ID of the current session.
     * @returns The ID of the current session.
     */
    getCurrentSessionId(): string;
    /**
     * Get the start time of the current session.
     * @returns The start time of the current session.
     */
    getCurrentSessionStartTime(): Date;
    /**
     * Get the selected model for the current session.
     * @returns The selected model or undefined if not set.
     */
    getSelectedModel(): string | undefined;
    /**
     * Get the current model with fallback to default.
     * @param executionModel Optional model from the execution engine
     * @returns The current model name, never undefined
     */
    getCurrentModel(executionModel?: string): string;
    /**
     * Set the selected model for the current session.
     * @param model The model to set.
     */
    setSelectedModel(model: SupportedModel): void;
    /**
     * Add a new timeline entry to the current session.
     * @param entry The timeline entry to add.
     */
    addTimelineEntry(entry: TimelineEntryWithoutID): void;
    /**
     * Clear the conversation history and timeline entries for the current session.
     * This removes all chat messages and timeline entries, effectively starting fresh
     * while keeping the same session ID.
     */
    clearHistory(): void;
    /**
     * Add a new chat message to the current session.
     * @param message The chat message to add.
     */
    addChatMessage(message: ChatCompletionMessageParam): void;
    /**
     * Get the chat context messages from the current session. These are used
     * to feed the LLM with relevant context before the user's prompt.
     * Excludes system messages but includes all other message types (user, assistant, tool, function, developer).
     * @param maxEntries The maximum number of entries to return.
     * @returns An array of chat context messages.
     */
    getChatContextMessages(): ChatCompletionMessageParam[];
    /**
     * Get all system messages from the current session.
     * @returns An array of system messages only.
     */
    getSystemContextMessages(): ChatCompletionMessageParam[];
    /**
     * Handle aborted operations by completing any pending tool calls with cancellation messages.
     * This provides consistent behavior whether interrupted by kill vs Esc/Ctrl+C.
     */
    handleAbortedOperation(): void;
    /**
     * Handles orphaned tool calls by adding cancelled tool result messages.
     * This prevents LLM errors when tool calls are interrupted and left incomplete.
     * Since interruptions happen during tool execution, we only need to check the end of the conversation.
     * Looks backwards through consecutive assistant messages with tool calls to handle multiple orphaned requests.
     * @param messages The messages to process
     * @returns Messages with cancelled tool results added for any orphaned tool calls
     */
    private completeOrphanedToolCalls;
    /**
     * Update the timeline entry for a tool call. This is used to update an existing
     * tool call entry with the result of that tool call.
     * @param result The result of the tool call.
     */
    updateToolCallTimelineEntryResult(result: ToolCallResult): void;
    /**
     * Update the timeline entry for a tool call. This is used to update an existing
     * tool call entry with the partial output of that tool call.
     * @param callId The ID of the tool call.
     * @param output The partial output of the tool call.
     */
    updateToolCallTimelineEntryPartialOutput(callId: string, output: string): void;
    /**
     * Resume a specific session by session ID or filename, otherwise errors.
     * @param sessionId The session ID (UUID) or filename part to resume. Supports partial matching.
     */
    private resumeSpecificSession;
    /**
     * Resume the last session, if one exists. Otherwise errors.
     * This picks the most recently modified session file.
     */
    private resumeLastSession;
    /** Generates a new history session with a random ID. */
    private generateSession;
    /** Generates a new session ID. */
    private generateSessionId;
    /**
     * Get the current usage metrics.
     * @returns The current usage metrics.
     */
    getUsageMetrics(): UsageMetrics;
    /**
     * Reset usage metrics for a new session.
     */
    resetUsageMetrics(): void;
    /**
     * Get the model request multiplier for a specific model.
     * @param modelName The name of the model.
     * @returns The multiplier for the model (default 1.0).
     */
    private getModelRequestMultiplier;
    /**
     * Track a user message submission.
     * @param modelName The name of the model being used (can be empty/undefined).
     */
    trackUserMessage(modelName: string): void;
    /**
     * Update usage metrics from a model API response.
     * @param modelName The name of the model (can be empty/undefined).
     * @param apiDurationMs The duration of the API call in milliseconds.
     * @param usage Token usage information from the API response.
     */
    updateModelUsageMetrics(modelName: string, apiDurationMs: number, usage?: {
        prompt_tokens?: number;
        completion_tokens?: number;
        prompt_tokens_details?: {
            cached_tokens?: number;
        };
    }): void;
    /**
     * Update code change metrics from a tool execution.
     * @param gitDiff The git diff output from the tool.
     * @param filePath The path of the file that was modified.
     */
    updateCodeChangeMetrics(gitDiff: string, filePath?: string): void;
    /**
     * Format token count for display.
     * @param count The token count.
     * @returns Formatted string (e.g., "1.2k", "3.5m").
     */
    private formatTokenCount;
    /**
     * Format duration for display.
     * @param ms Duration in milliseconds.
     * @returns Formatted string (e.g., "4m 13.8s", "1h 2m 16.2s").
     */
    private formatDuration;
    /**
     * Get formatted usage output for display.
     * @returns Formatted string with usage metrics.
     */
    getFormattedUsageOutput(): string;
}

export declare interface SessionManagerOptions {
    /**
     * Logger instance for the session manager
     */
    logger?: RunnerLogger;
}

export declare interface SessionMetadata {
    readonly id: string;
    readonly startTime: Date;
    readonly selectedModel?: string;
}

export declare type SessionStartHook = (input: SessionStartHookInput) => Promise<SessionStartHookOutput | void>;

/**
 * Session start hook types
 */
export declare interface SessionStartHookInput extends BaseHookInput {
    source: "startup" | "resume" | "new";
    initialPrompt?: string;
}

export declare interface SessionStartHookOutput {
    additionalContext?: string;
    modifiedConfig?: Record<string, unknown>;
}

/**
 * A permission request for executing shell commands.
 */
declare type ShellPermissionRequest = {
    readonly kind: "shell";
    /** The full command that the user is being asked to approve, e.g. `echo foo && find -exec ... && git push` */
    readonly fullCommandText: string;
    /** A concise summary of the user's intention, e.g. "Echo foo and find a file and then run git push" */
    readonly intention: string;
    /**
     * The commands that are being invoked in the shell invocation.
     *
     * As a special case, which might be better represented in the type system, if there were no parsed commands
     * e.g. `export VAR=value`, then this will have a single entry with identifier equal to the fullCommandText.
     */
    readonly commands: ReadonlyArray<Command>;
    /**
     * Possible file paths that the command might access.
     *
     * This is entirely heuristic, so it's pretty untrustworthy.
     */
    readonly possiblePaths: ReadonlyArray<PossiblePath>;
    /**
     * Indicates whether any command in the script has redirection to write to a file.
     */
    readonly hasWriteFileRedirection: boolean;
    /**
     * If there are complicated constructs, then persistent approval is not supported.
     * e.g. `cat $(echo "foo")` should not be persistently approvable because it's hard
     * for the user to understand the implications.
     */
    readonly canOfferSessionApproval: boolean;
};

/** List of supported models in order of precedence to be used as the default */
declare const SUPPORTED_MODELS: readonly ["claude-sonnet-4.5", "claude-sonnet-4", "gpt-5"];

declare type SupportedModel = (typeof SUPPORTED_MODELS)[number];

/**
 * Telemetry emitted by the runtime contains properties and metrics. These are non-sensitive pieces
 * of information. There are also restricted properties that must be used to store sensitive information.
 */
declare type Telemetry = {
    /**
     * Telemetry properties can be used to store string props.
     * WARNING: Do not put sensitive data here. Use restrictedProperties for that.
     */
    properties: Record<string, string | undefined>;
    /**
     * Restricted telemetry properties must be used to store sensitive string props. These props will only be available on the restricted kusto topics.
     * Nonnullable so it is harder to overlook.
     */
    restrictedProperties: Record<string, string | undefined>;
    /**
     * The name of the telemetry event associated with the emitted runtime event.
     */
    metrics: Record<string, number | undefined>;
};

declare type TimelineEntry = z.infer<typeof TimelineEntrySchema>;

declare const TimelineEntrySchema: z.ZodIntersection<z.ZodUnion<[z.ZodObject<{
    type: z.ZodLiteral<"copilot">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "copilot";
    text: string;
}, {
    type: "copilot";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"error">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "error";
    text: string;
}, {
    type: "error";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"info">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "info";
    text: string;
}, {
    type: "info";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"user">;
    text: z.ZodString;
    expandedText: z.ZodOptional<z.ZodString>;
    mentions: z.ZodOptional<z.ZodArray<z.ZodObject<{
        displayText: z.ZodString;
        fullPath: z.ZodString;
        type: z.ZodEnum<["file", "directory", "unresolved", "image"]>;
        startIndex: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }, {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }>, "many">>;
    imageAttachments: z.ZodOptional<z.ZodArray<z.ZodObject<{
        type: z.ZodLiteral<"image_url">;
        image_url: z.ZodObject<{
            url: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            url: string;
        }, {
            url: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        type: "image_url";
        image_url: {
            url: string;
        };
    }, {
        type: "image_url";
        image_url: {
            url: string;
        };
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    type: "user";
    text: string;
    expandedText?: string | undefined;
    mentions?: {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }[] | undefined;
    imageAttachments?: {
        type: "image_url";
        image_url: {
            url: string;
        };
    }[] | undefined;
}, {
    type: "user";
    text: string;
    expandedText?: string | undefined;
    mentions?: {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }[] | undefined;
    imageAttachments?: {
        type: "image_url";
        image_url: {
            url: string;
        };
    }[] | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"tool_call_requested">;
    callId: z.ZodString;
    name: z.ZodString;
    toolTitle: z.ZodOptional<z.ZodString>;
    intentionSummary: z.ZodNullable<z.ZodString>;
    arguments: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
        command: z.ZodString;
        description: z.ZodString;
        timeout: z.ZodOptional<z.ZodNumber>;
        sessionId: z.ZodOptional<z.ZodString>;
        async: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        input: z.ZodString;
        delay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        delay: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
        delay: number;
    }, {
        sessionId: string;
        delay: number;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
    }, {
        sessionId: string;
    }>]>, z.ZodDiscriminatedUnion<"command", [z.ZodObject<{
        command: z.ZodLiteral<"view">;
        path: z.ZodString;
        view_range: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber], null>>;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"create">;
        path: z.ZodString;
        file_text: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "create";
        file_text: string;
    }, {
        path: string;
        command: "create";
        file_text: string;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"str_replace">;
        path: z.ZodString;
        new_str: z.ZodOptional<z.ZodString>;
        old_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"insert">;
        path: z.ZodString;
        insert_line: z.ZodNumber;
        new_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }>]>, z.ZodUnknown]>;
    partialOutput: z.ZodOptional<z.ZodString>;
    isHidden: z.ZodOptional<z.ZodBoolean>;
    isAlwaysExpanded: z.ZodOptional<z.ZodBoolean>;
    showNoContent: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    name: string;
    type: "tool_call_requested";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    partialOutput?: string | undefined;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}, {
    name: string;
    type: "tool_call_requested";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    partialOutput?: string | undefined;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"tool_call_completed">;
    callId: z.ZodString;
    name: z.ZodString;
    toolTitle: z.ZodOptional<z.ZodString>;
    intentionSummary: z.ZodNullable<z.ZodString>;
    result: z.ZodUnion<[z.ZodObject<{
        type: z.ZodLiteral<"success">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"failure">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"rejected">;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        type: "rejected";
        markdown?: boolean | undefined;
    }, {
        type: "rejected";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"denied">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    }>]>;
    arguments: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
        command: z.ZodString;
        description: z.ZodString;
        timeout: z.ZodOptional<z.ZodNumber>;
        sessionId: z.ZodOptional<z.ZodString>;
        async: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        input: z.ZodString;
        delay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        delay: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
        delay: number;
    }, {
        sessionId: string;
        delay: number;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
    }, {
        sessionId: string;
    }>]>, z.ZodDiscriminatedUnion<"command", [z.ZodObject<{
        command: z.ZodLiteral<"view">;
        path: z.ZodString;
        view_range: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber], null>>;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"create">;
        path: z.ZodString;
        file_text: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "create";
        file_text: string;
    }, {
        path: string;
        command: "create";
        file_text: string;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"str_replace">;
        path: z.ZodString;
        new_str: z.ZodOptional<z.ZodString>;
        old_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"insert">;
        path: z.ZodString;
        insert_line: z.ZodNumber;
        new_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }>]>, z.ZodUnknown]>;
    isHidden: z.ZodOptional<z.ZodBoolean>;
    isAlwaysExpanded: z.ZodOptional<z.ZodBoolean>;
    showNoContent: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    result: {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    } | {
        type: "rejected";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    };
    name: string;
    type: "tool_call_completed";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}, {
    result: {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    } | {
        type: "rejected";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    };
    name: string;
    type: "tool_call_completed";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}>]>, z.ZodObject<{
    id: z.ZodString;
    timestamp: z.ZodDate;
}, "strip", z.ZodTypeAny, {
    id: string;
    timestamp: Date;
}, {
    id: string;
    timestamp: Date;
}>>;

declare type TimelineEntryWithoutID = z.infer<typeof TimelineEntryWithoutIDSchema>;

declare const TimelineEntryWithoutIDSchema: z.ZodUnion<[z.ZodObject<{
    type: z.ZodLiteral<"copilot">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "copilot";
    text: string;
}, {
    type: "copilot";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"error">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "error";
    text: string;
}, {
    type: "error";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"info">;
    text: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "info";
    text: string;
}, {
    type: "info";
    text: string;
}>, z.ZodObject<{
    type: z.ZodLiteral<"user">;
    text: z.ZodString;
    expandedText: z.ZodOptional<z.ZodString>;
    mentions: z.ZodOptional<z.ZodArray<z.ZodObject<{
        displayText: z.ZodString;
        fullPath: z.ZodString;
        type: z.ZodEnum<["file", "directory", "unresolved", "image"]>;
        startIndex: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }, {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }>, "many">>;
    imageAttachments: z.ZodOptional<z.ZodArray<z.ZodObject<{
        type: z.ZodLiteral<"image_url">;
        image_url: z.ZodObject<{
            url: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            url: string;
        }, {
            url: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        type: "image_url";
        image_url: {
            url: string;
        };
    }, {
        type: "image_url";
        image_url: {
            url: string;
        };
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    type: "user";
    text: string;
    expandedText?: string | undefined;
    mentions?: {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }[] | undefined;
    imageAttachments?: {
        type: "image_url";
        image_url: {
            url: string;
        };
    }[] | undefined;
}, {
    type: "user";
    text: string;
    expandedText?: string | undefined;
    mentions?: {
        type: "file" | "directory" | "image" | "unresolved";
        displayText: string;
        fullPath: string;
        startIndex: number;
    }[] | undefined;
    imageAttachments?: {
        type: "image_url";
        image_url: {
            url: string;
        };
    }[] | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"tool_call_requested">;
    callId: z.ZodString;
    name: z.ZodString;
    toolTitle: z.ZodOptional<z.ZodString>;
    intentionSummary: z.ZodNullable<z.ZodString>;
    arguments: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
        command: z.ZodString;
        description: z.ZodString;
        timeout: z.ZodOptional<z.ZodNumber>;
        sessionId: z.ZodOptional<z.ZodString>;
        async: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        input: z.ZodString;
        delay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        delay: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
        delay: number;
    }, {
        sessionId: string;
        delay: number;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
    }, {
        sessionId: string;
    }>]>, z.ZodDiscriminatedUnion<"command", [z.ZodObject<{
        command: z.ZodLiteral<"view">;
        path: z.ZodString;
        view_range: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber], null>>;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"create">;
        path: z.ZodString;
        file_text: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "create";
        file_text: string;
    }, {
        path: string;
        command: "create";
        file_text: string;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"str_replace">;
        path: z.ZodString;
        new_str: z.ZodOptional<z.ZodString>;
        old_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"insert">;
        path: z.ZodString;
        insert_line: z.ZodNumber;
        new_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }>]>, z.ZodUnknown]>;
    partialOutput: z.ZodOptional<z.ZodString>;
    isHidden: z.ZodOptional<z.ZodBoolean>;
    isAlwaysExpanded: z.ZodOptional<z.ZodBoolean>;
    showNoContent: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    name: string;
    type: "tool_call_requested";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    partialOutput?: string | undefined;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}, {
    name: string;
    type: "tool_call_requested";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    partialOutput?: string | undefined;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}>, z.ZodObject<{
    type: z.ZodLiteral<"tool_call_completed">;
    callId: z.ZodString;
    name: z.ZodString;
    toolTitle: z.ZodOptional<z.ZodString>;
    intentionSummary: z.ZodNullable<z.ZodString>;
    result: z.ZodUnion<[z.ZodObject<{
        type: z.ZodLiteral<"success">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"failure">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"rejected">;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        type: "rejected";
        markdown?: boolean | undefined;
    }, {
        type: "rejected";
        markdown?: boolean | undefined;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"denied">;
        log: z.ZodString;
        markdown: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    }, {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    }>]>;
    arguments: z.ZodUnion<[z.ZodUnion<[z.ZodObject<{
        command: z.ZodString;
        description: z.ZodString;
        timeout: z.ZodOptional<z.ZodNumber>;
        sessionId: z.ZodOptional<z.ZodString>;
        async: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }, {
        command: string;
        description: string;
        sessionId?: string | undefined;
        timeout?: number | undefined;
        async?: boolean | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        input: z.ZodString;
        delay: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }, {
        input: string;
        sessionId: string;
        delay?: number | undefined;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
        delay: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
        delay: number;
    }, {
        sessionId: string;
        delay: number;
    }>, z.ZodObject<{
        sessionId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        sessionId: string;
    }, {
        sessionId: string;
    }>]>, z.ZodDiscriminatedUnion<"command", [z.ZodObject<{
        command: z.ZodLiteral<"view">;
        path: z.ZodString;
        view_range: z.ZodOptional<z.ZodTuple<[z.ZodNumber, z.ZodNumber], null>>;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }, {
        path: string;
        command: "view";
        view_range?: [number, number] | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"create">;
        path: z.ZodString;
        file_text: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "create";
        file_text: string;
    }, {
        path: string;
        command: "create";
        file_text: string;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"str_replace">;
        path: z.ZodString;
        new_str: z.ZodOptional<z.ZodString>;
        old_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }, {
        path: string;
        command: "str_replace";
        old_str: string;
        new_str?: string | undefined;
    }>, z.ZodObject<{
        command: z.ZodLiteral<"insert">;
        path: z.ZodString;
        insert_line: z.ZodNumber;
        new_str: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }, {
        path: string;
        command: "insert";
        new_str: string;
        insert_line: number;
    }>]>, z.ZodUnknown]>;
    isHidden: z.ZodOptional<z.ZodBoolean>;
    isAlwaysExpanded: z.ZodOptional<z.ZodBoolean>;
    showNoContent: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    result: {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    } | {
        type: "rejected";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    };
    name: string;
    type: "tool_call_completed";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}, {
    result: {
        log: string;
        type: "success";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "failure";
        markdown?: boolean | undefined;
    } | {
        type: "rejected";
        markdown?: boolean | undefined;
    } | {
        log: string;
        type: "denied";
        markdown?: boolean | undefined;
    };
    name: string;
    type: "tool_call_completed";
    callId: string;
    intentionSummary: string | null;
    toolTitle?: string | undefined;
    arguments?: unknown;
    isHidden?: boolean | undefined;
    isAlwaysExpanded?: boolean | undefined;
    showNoContent?: boolean | undefined;
}>]>;

declare type ToolCallResult = {
    callId: string;
    resultType: "success" | "failure" | "rejected" | "denied";
    log: string;
    markdown?: boolean;
};

declare type ToolResultExpanded<TelemetryT extends Telemetry = Telemetry> = {
    /**
     * The result to be given back to the LLM.
     *
     * If @see sessionLog is omitted, then this will be used as the session log.
     */
    textResultForLlm: string;
    /**
     * The result to be given back to the LLM. It can be either base64 encoded image or audio content.
     */
    binaryResultForLlm?: BinaryResult[];
    /**
     * Whether or not the result should be considered a success, failure, or previously interrupted.
     * - `success`: The tool executed successfully and produced a valid result.
     * - `failure`: The tool encountered an error or did not produce a valid result.
     * - `rejected`: The tool call was rejected either because the user didn't want this call, or a previous dependent one.
     * - `denied`: The tool call was denied because the permissions service said no.
     */
    resultType: "success" | "failure" | "rejected" | "denied";
    /**
     * If there was any sort of error that caused the tool to fail, then a string representation of the error. Typically
     * only set if {@link resultType} is `'failure'`.
     */
    error?: string;
    /**
     * Specific telemetry for the tool. Will be sent back to the server by the agent.
     */
    toolTelemetry: {
        properties?: TelemetryT["properties"];
        restrictedProperties?: TelemetryT["restrictedProperties"];
        metrics?: TelemetryT["metrics"];
    };
    /**
     * Well-formatted (typically Markdown) string that can be used to display the input/output of the tool invoked.
     *
     * (Optional) If omitted, the text result for the LLM will be used as the session log.
     */
    sessionLog?: string;
};

declare interface UsageMetrics {
    totalPremiumRequests: number;
    totalApiDurationMs: number;
    sessionStartTime: number;
    codeChanges: CodeChangeMetrics;
    modelMetrics: Map<string, ModelMetrics>;
    currentModel?: string;
}

export declare type UserPromptSubmittedHook = (input: UserPromptSubmittedHookInput) => Promise<UserPromptSubmittedHookOutput | void>;

/**
 * User prompt submitted hook types
 */
export declare interface UserPromptSubmittedHookInput extends BaseHookInput {
    prompt: string;
}

export declare interface UserPromptSubmittedHookOutput {
    modifiedPrompt?: string;
    additionalContext?: string;
    suppressOutput?: boolean;
}

/**
 * A permission request for writing to new or existing files.
 */
declare type WritePermissionRequest = {
    readonly kind: "write";
    /** The intention of the edit operation, e.g. "Edit file" or "Create file" */
    readonly intention: string;
    /** The name of the file being edited */
    readonly fileName: string;
    /** The diff of the changes being made */
    readonly diff: string;
};

export { }
